'''
Institution: Max-Planck Institution for Radioastronomy (MPIfR-Bonn)
    Auf dem Huegel 69, Bonn, Germany

Author: Niclas Eesser <nesser@mpifr-bonn.mpg.de>

Description
-----------
    This script allows to read raw data in CODIF format and process them to an HDF5
    based ACM (Array Covariance Matrices) file.
    The structure of the HDF5 file is specified by CSIRO. Thus, this script provides
    a way to process the recorded raw data (snapshots) to ACMs and store them dircetly
    into a standardised format. The ACM files are very useful for further processing steps.
    For instance, a file generated by this script can be directly processed by the BeamweightCalculation
    tool (https://gitlab.mpcdf.mpg.de/nesser/beamcalculator/-/tree/version_1.1)

Preliminaries
-------------
    The script expects a predefined folder structure in which the raw data are stored:
    root_dir/
    |_______numa0/
    |        |______raw_file1.dada
    |        |______raw_file2.dada
    :        :
    |        |______raw_fileN.dada
    |_______numa1/
    |        |______raw_file1.dada
    |        |______raw_file2.dada
    :        :
    |        |______raw_fileN.dada
    :
    |_______numaN/
             |______raw_file1.dada
             |______raw_file2.dada
             :
             |______raw_fileN.dada
    All files within the folder structure are automatically searched, but it is important
    that sub-folders have the name 'numa' + ID
Program flow
------------
    0. Parse user arguments
    1. Setup necessary numpy arrays
    2. Get and read all files of a numa node or a subfrequency group (7MHz), respectivly, by using CodifHandler object
    3. Compute ACM data from frequency group and assign the data to array (8,48,192,192) as expected from the HDF5 structure
    4. Jump back to 2. and iterate over all desired frequency groups / numa nodes
    5. Create a frequency list
    6. Create a dictionary containg all computed and passed data, which has the structure of the HDF5 file
    7. Create HDF5 file, write information of dictionary to HDF5 file and close it
'''
# Included modules
import argparse
import glob
import numpy as np
from argparse import RawTextHelpFormatter

# Custom modules
from inc.codif import *
from inc.utils import *
from inc.acm_hdf5 import *


if __name__ == '__main__':
    ##############################
    # Start of arguments parsing #
    ##############################
    parser = argparse.ArgumentParser(description='options', formatter_class=RawTextHelpFormatter)#, help="Converts/processes raw data to HDF5 based ACM files")
    parser.add_argument('--fname', '-f', action = "store", default = "*", dest = "fname", help = "Input filename expression. If not passed all files within a subfolder are read")
    parser.add_argument('--dir', '-d', action = "store", default = "/beegfsEDD/NESSER/PAF-12-2020/2020-12-09/2020-12-09-15:57:51/", dest = "dir", help = "Path to root folder")
    parser.add_argument('--output_dir', '-o', action = "store", default="", dest="odir", help = "Directory + filename for storage of the generated ACM file .")
    parser.add_argument('--sbid', '-i', action = "store", default=9999, dest="sbid", help="Observation ID ")
    parser.add_argument('--nelements', '-n', action = "store", default=36, dest="nelements", help="Number of dual-polarized antenna elements. By default it is set to 36 which is the maximum .")
    parser.add_argument('--nnodes', '-nn', action = "store", default=16, dest="nnodes", help="Number of nodes. If set to N all folders between numa0 and numaN are read. If not set all subfolders are read")
    parser.add_argument('--antenna', '-at', action = "store", default=1, dest="antenna", help="Antenna ID. Always set to 1")
    parser.add_argument('--site', '-st', action = "store", default='pk ', dest="site", help="Name of ")
    parser.add_argument('--schedulingblock', '-sb', action = "store", default=0, dest="schedulingblock", help="schedulingblock")
    parser.add_argument('--band', '-b', action = "store", default="FILTER_1450", dest="band", help="Filter band")
    parser.add_argument('--center', '-fc', action = "store", default=1340, dest="fc", help="Center frequency")
    parser.add_argument('--comment', '-c', action = "store", default="no comment", dest="comment", help="Add a comment to the HDF5 file")
    parser.add_argument('--azimuth', '-a', action = "store", default=90.0, dest="azimuth", help="Azimuth angle ")
    parser.add_argument('--elevation', '-e', action = "store", default=90.0, dest="elevation", help="Elevation angle ")
    parser.add_argument('--bat', '-ba', action = "store", default=5103284240024128, dest="bat", help="Dunno ")
    parser.add_argument('--decJ2000', '-dj', action = "store", default=42.2361, dest="decj2000", help="Declination ")
    parser.add_argument('--raJ2000', '-rj', action = "store", default=316.757, dest="raj2000", help="Center frequency")
    parser.add_argument('--rollAngle', '-ra', action = "store", default=90.0, dest="roll_angle", help="Roll angle ")
    parser.add_argument('--on_source', '-on', action = "store", default=1, dest="on_source", help="0: off-source observation, 1: on-source observation")
    # Assign arguments to variables for readability
    fname = parser.parse_args().fname
    idir = parser.parse_args().dir
    odir = parser.parse_args().odir
    nelements = int(parser.parse_args().nelements)
    nnodes = int(parser.parse_args().nnodes)
    antenna = parser.parse_args().antenna
    site = parser.parse_args().site
    sbid = parser.parse_args().sbid
    schedulingblock = parser.parse_args().schedulingblock
    band = parser.parse_args().band
    fc = parser.parse_args().fc
    comment = parser.parse_args().comment
    azimuth = parser.parse_args().azimuth
    elevation = parser.parse_args().elevation
    bat = parser.parse_args().bat
    decj2000 = parser.parse_args().decj2000
    raj2000 = parser.parse_args().raj2000
    roll_angle = parser.parse_args().roll_angle
    on_source = parser.parse_args().on_source
    # Parse lowest frequency
    freq_low = fc - PAF_BANDWIDTH/2
    # Auto set output dir + filename if argument was not passed
    if odir == "":
        odir = "SB0" +str(sbid)+ ".pk01.acm.hdf5"
    check_dir(odir.rsplit('/',1)[0])
    ##############################
    #  End of arguments parsing  #
    ##############################

    # 1. Generate numpy array to store data
    freq_dict = {}
    bandwidth = np.arange(freq_low, freq_low + PAF_BANDWIDTH)
    flagged = np.ones((1+CODIF_CHANNELS_IN_BLOCK, PAF_N_FREQ_GROUP))
    frames = np.zeros((1+CODIF_CHANNELS_IN_BLOCK, PAF_N_FREQ_GROUP), dtype="float") # Frames per cycle and frequency group
    sky_frequency = np.zeros((1+CODIF_CHANNELS_IN_BLOCK, PAF_N_FREQ_GROUP), dtype="float") # All occuring frequencies with 1MHz bandwidth
    acm = np.zeros((1+CODIF_CHANNELS_IN_BLOCK, PAF_N_FREQ_GROUP, N_ELEMENTS, N_ELEMENTS), dtype=np.complex64)  # Array to store ACM data
    # 2. - 4. Iterate over each numa node / subfolder
    for id in range(0,nnodes):
        # 2. Get and read files
        dir = check_slash(idir) + "numa" + str(id) + "/"
        print("Working on subdirectory: " + dir)
        files = get_file_list(dir, fname + "*")
        handler = CodifHandler(files)
        # 3. Compute and fill up
        acm_data, freq, frame_cnt = handler.compute_acm(nelements)
        if frame_cnt > 10:
            for f in freq:
                freq_dict[str(f)] = frame_cnt
            acm += fillup_acm(acm_data, ELEMENT_LIST, freq)


    # 5. Create a frequency list
    for idx in range(1+CODIF_CHANNELS_IN_BLOCK):
        sky_frequency[idx, :] = np.arange(freq_low + idx, freq_low + PAF_BANDWIDTH, 8)
    for key, value in freq_dict.items():
        pos = np.argwhere(sky_frequency==float(key))
        frames[pos[0,0], pos[0,1]] = value
        flagged[pos[0,0], pos[0,1]] = 0
        # print(sky_frequency[pos[0,0], pos[0,1]])

    # 6. Generate the dictionary depending on all user arguments and computete results
    dictionary = data_to_dict(acm, sky_frequency, frames, flagged=flagged, odir=odir, antenna=antenna, \
        sbid=sbid, site=site, schedulingblock=schedulingblock, band=band, fc=fc, \
        comment=comment, azimuth=azimuth, elevation=elevation, bat=bat, \
        decj2000=decj2000, raj2000=raj2000, roll_angle=roll_angle, on_source=on_source)
    # 7. Create, write and close
    acm_file = ACMFile(odir, 'w')
    acm_file.create_from_dict(dictionary)
    acm_file.close()
